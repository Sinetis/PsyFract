
#define PI 3.1415926535897932384626433832795f
#define twoPI 6.283185307179586476925286766559f
#define halfPI 1.5707963267948966192313216916398f

struct  Complex
{
	float x;
		float& Re() {return x;}
	float y;
		float& Im() {return y;}
		
	Complex(float re = 0, float im = 0)
		:x(re), y(im)
	{	}
	
	Complex(const Complex& val)
		:x(val.x), y(val.y)
	{	}

	Complex i()
	{return Complex(0.0f, 1.0f);}

	Complex operator= (Complex val)
	{
		this->x = val.x;
		this->y = val.y;
		return *this;
	}
	
	Complex operator+ (Complex val)
	{
		return Complex(this->x + val.x, this->y + val.y);
	}
	Complex operator+= (Complex val)
	{
		return *this = *this + val;
	}

	Complex operator- (Complex val)
	{
		return Complex(this->x - val.x, this->y - val.y);
	}
	Complex operator- ()
	{
		return Complex(-x, -y);
	}
	
	Complex operator* (Complex val)
	{
		// (x1 + iy1) * (x2 + iy2)
		Complex res;
		res.x = this->x * val.x - this->y * val.y;
		res.y = this->x * val.y + this->y * val.x;
		return res;
	}
	Complex operator*= (Complex val)
	{
		return *this = *this * val;
	}
	
	Complex operator/ (Complex val)
	{
		// (x1 + iy1) / (x2 + iy2)
		Complex res;
		float f = val.s();
		res.x = (this->x * val.x + this->y * val.y) / f;
		res.y = (-this->x * val.y + this->y * val.x) / f;
		return res;
	}

	Complex operator()(float re, float im = 0.f)
	{
		return Complex(re, im);
	}

	//inline __device__ operator float () const
	//{
	//	return sqrtf(this->x * this->x + this->y * this->y);
	//}
	// Модуль числа
	float d(){return sqrtf(this->x * this->x + this->y * this->y);}
	// Квадрат модуля числа
	float s()
	{return this->x * this->x + this->y * this->y;}
	// Аргумент числа
	float arg()
	{
		if (x > 0)
			return atanf(y/x);
		if (y > 0)
			return atanf(y/x)+PI;
		else
			return atanf(y/x)-PI;
	}

	Complex operator +(float val)
	{
		return Complex(this->x+val, this->y);
	}

	Complex operator +=(float val)
	{
		this->x += val;
		return *this;
	}
	Complex operator -(float val)
	{
		return Complex(this->x-val, this->y);
	}

	Complex operator -=(float val)
	{
		this->x -= val;
		return *this;
	}

	Complex operator *(float val)
	{	
		return Complex(this->x*val, this->y*val);
	}

	Complex operator /(float val)
	{
		return Complex(this->x/val, this->y/val);
	}
	Complex operator /=(float val)
	{ return *this = *this / val; }

	Complex operator =(float val)
	{
		x = val;
		y = 0;
		return *this;
	}
	Complex operator^ (int val)
	{
		Complex c = *this;
		bool minus = val < 0;
		val = minus ? -val : val;
		for (int i = 1; i < val; i++) c *= *this;
		c = minus ? c.Inverse() : c;
		return c;
	}

	static Complex Zero()
	{
		return Complex(0,0);
	}

	// Поворот в радианах
	Complex Rotate(float fi)
	{
		Complex res;
		float c = cosf(fi), s = sinf(fi);
		res.x = x*c - y*s;
		res.y = x*s + y*c;
		return res;
	}

	void Scale(float k)
	{
		this->x *= k;
		this->y *= k;
	}

	void Shift(Complex c)
	{
		Shift(c.x, c.y);
	}
	void Shift(float cx, float cy)
	{
		this->x += cx;
		this->y += cy;
	}

	Complex Inverse()
	{
		Complex c(x, y);
		float m = x*x + y*y;
		c.x /= m;
		c.y /= -m;
		return c;
	}

	Complex exp()
	{
		Complex c;
		float e;
		e = expf(x); 
		c.x = e*cosf(y);
		c.y = e*sinf(y);
		return c;
	}

	Complex Ln()
	{
		Complex c;
		c.y = arg();
		c.x = logf(this->d());
		return c;
	}
	
	Complex sin()
	{
		Complex c, eiz(0.f,1.f);
		eiz = (eiz * (*this)).exp(); 
		c = eiz - eiz.Inverse();
		c = c / Complex(0.f, 2.f);
		return c;
	}
	Complex cos()
	{
		Complex c, eiz(0.f,1.f);
		eiz = (eiz * (*this)).exp(); 
		c = eiz + eiz.Inverse();
		c = c / Complex(2.f, 0.f);
		return c;
	}

	Complex ch()
	{
		Complex c, ez(1.f,0.f);
		ez = (ez * (*this)).exp(); 
		c = ez + ez.Inverse();
		c = c / Complex(2.f, 0.f);
		return c;
	}
	Complex sh()
	{
		Complex c, ez(1.f,0.f);
		ez = (ez * (*this)).exp(); 
		c = ez - ez.Inverse();
		c = c / Complex(2.f, 0.f);
		return c;
	}

	Complex sqrt(bool root = false)
	{
		Complex c;
		float r = sqrtf(this->d());
		float a = (this->arg() + twoPI*root)/2;
		c.y = sinf(a)*r;
		c.x = cosf(a)*r;
		return c;
	}

	Complex asin(bool root = false)
	{
		Complex s = (-(*this)*(*this) + 1.f).sqrt(root);
		return Complex(0.f, -1.f)*(*this*cuComplex(0.f, 1.f) + s).Ln();
	}
	Complex acos(bool root = false, bool sign = true)
	{
		return Complex(halfPI, 0.f) - asin(root);
	}

	Complex atan()
	{
		Complex iz = (*this)*i();
		return ((-iz + 1.0f).Ln() - (iz + 1.0f).Ln())*(Complex(0.0f, 0.5f));
	}

	Complex pow(float a, float b = 0.0f)
	{
		float sr = x*x+y*y;
		float r, fi;
		fi = this->arg();
		r = powf(sr, a/2.0f)/(expf(fi*b));
		fi = a*fi + b*logf(sr)/2.0f;

		Complex res;
		res.x = r*cosf(fi);
		res.y = r*sinf(fi);
		return res;
	}
	Complex pow(Complex val)
	{
		return pow(val.x, val.y);
	}
	Complex pow(int val)
	{
		Complex c = *this;
		bool minus = val < 0;
		val = minus ? -val : val;
		for (int i = 1; i < val; i++) c *= *this;
		c = minus ? c.Inverse() : c;
		return c;
	}
};

struct data
{
	int iter;
	float k;
	int frac;
	unsigned int col;
};

inline Complex Fracs(Complex z, Complex C, Complex*c, int frac, int k)
{
	switch (frac)
	{
	case 1:
		return z - ((-z*z).exp() - 1.0f)/C + c[1].x;
	case 2:
		return z*z*z.Ln() + C;
	case 3:
		return z*z.exp()*c[2].x + z*z.Ln()*c[1].x + C;
	case 4:
		return z - z(2.0f+c[1].x/10.f)*((z*z*z*z - 1.0f)/(z*z*z*4.0f - c[2].x)) + C;
	case 5:
		return z - z(2.0f)*((z*z*z - 1.0f)/(z*z*3.0f)) + C;
	case 6:
		return z - (z(0.7f + c[0].x*2.f)*(z*z*z - 1.0f)/(z*z*3.f)).pow(2) + C; 
	case 7:
		return (z*z*z*2.0f)/(z*z*3.0f + c[0] * c[3]) + clComplex(0.05f,c[0].y/10.0f).Rotate(k/PI);
	case 8:
		return z - (z.exp()/z + C)/(z.exp()/z - z.exp()/(z*z));
	case 9:
		return z.exp();
	case 10:
		return z.Ln();
	case 11:
		return z.sin();
	case 12:
		return z.ch();
	case 13:
		return z.asin();
	case 14:
		return z - z.exp() + C;
	case 15:
		return c[0] + c[1]*z + c[2]*z*z + c[3]*z*z*z + C;
	case 16:
		return z - z.sin() + C;
	case 17:
		return z - z.ch() + C;
	case 18:
		return z - z.sin()*(c[1].x+c[2].x) + C;
	case 19:
		return (-z*z).exp() + C;
	case 20:
		return (z+c[0].y)*c[0].x + (z/(C - c[2].y))*c[2].x + (z*z)*c[3].x + C;
	case 21:
		return clComplex(cosf(z.x), -sinf(z.y));
	case 22:
		return c[0]*(z.i()*C*z).exp() + c[1]*(-z.i()*C*z).exp() + (C*C).Inverse(); 
	case 23:
		return (z+c[2].x).sin()*(z+c[1].x).cos() + C;
	default:
		return ((z*z + C) / (z*2.0f + C - 2)).pow(2) + 1 + c[1].x;
	}
}

void function(Complex& z, Complex C, Complex* c, data st)
{
	z = Fracs(z, C, c, st.frac/1024, st.k);
	if (st.frac&1)
		z = Fracs(z, C, c, (st.frac%1024)/2, st.k);
}

void OpenCLFractal(	cl_float4 posData, uchar4* pix, int xPixels, 
					__constant Complex* c, data st, bool t)
{
	unsigned int idx = get_global_id(0);
	Complex C, z, zn;
	if (t)
	{
		C = Complex(posData.y + posData.w*(idx / xPixels), posData.x + posData.w*(idx % xPixels));
		//z = C/c[0].x;
		z = Complex(c[0].x);
	}
	else
	{
		z = Complex(posData.y + posData.w*(idx / xPixels), posData.x + posData.w*(idx % xPixels));
		//C = z/c[0].x;
		C = Complex(c[0].x);
	}
	int it = 0;
	float s;
	do
	{
		zn = z;
		function(z, C, c, st);
		it++;
		s = (z-zn).s();
	}
	while (it < st.iter && s > 1.0e-5);// && s < 1.0e10);

	float color = it*2.0f + 7*c[0].x + st.k;
	int r,g,b;
	b = (char(127 * cosf(color/266.0f+4*c[1].x)) + 128);
	g = (char(127 * cosf(color/15.0f+4*c[2].x)) + 128);
	r = (char(127 * cosf(color/4.0f+4*c[3].x)) + 128);
	
	if (st.col&1) r = 255 - r;
	if (st.col&2) g = 255 - g;
	if (st.col&4) b = 255 - b;

	pix[idx][0] = r;
	pix[idx][1] = g;
	pix[idx][2] = b;
	pix[idx][3] = 255;
}